Contract PoapFactoryV2(
    collectionTemplateId: ByteVec,
    collectionTemplateSeriesId: ByteVec,
    poapTemplateId: ByteVec,
    poapTemplateSeriesId: ByteVec,
    poapTemplateDataId: ByteVec,
    mut numMintedCollection: U256
){

    event EventCreated(contractId: ByteVec, eventName: ByteVec, organizer: Address, isPublic: Bool, timestamp: U256, isSeries: Bool)
    event PoapMinted(contractId: ByteVec, collectionId: PoapCollectionV2, nftIndex: U256 ,caller: Address, isPublic: Bool, timestamp: U256)
    event PoapSerieMinted(contractId: ByteVec, collectionId: PoapSerieCollectionV2, eventId: U256, nftIndex: U256 ,caller: Address, isPublic: Bool, timestamp: U256)
    event PoapParticipatedIn(organizerAddress: Address, collectionId: PoapCollectionV2, nftIndex: U256, presenceAddressValidate: Address)
    event SerieAdded(collectionId: PoapSerieCollectionV2, eventContractId: ByteVec ,eventName: ByteVec, organizer: Address ,isPublic: Bool, timestamp: U256)


    @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true)
    pub fn mintNewCollection(
        maxSupply: U256,
        mintStartAt: U256,
        mintEndAt: U256,
        oneMintPerAddress: Bool,
        poapPrice: U256,
        tokenIdPoap: ByteVec,
        isOpenPrice: Bool,
        tokenIdAirdrop: ByteVec,
        amountAirdropPerUser: U256,
        airdropWhenHasParticipated: Bool,
        hashedPassword: ByteVec,
        lockPresenceUntil: U256,

        //event properties
        eventImage: ByteVec,
        eventName: ByteVec,
        description: ByteVec,
        location: ByteVec,
        eventStartAt: U256,
        eventEndAt: U256,
        isPublic: Bool,
        isBurnable: Bool,

        amountForStorageFees: U256,
        amountForChainFees: U256,
        amountPoapFees: U256,
        totalSupply: U256,
        amountAirdrop: U256
        ) -> (ByteVec){
            let caller = callerAddress!()

            let (initialImmState, initialMutState) = PoapCollectionV2.encodeFields!(
                poapTemplateId,
                maxSupply,
                mintStartAt,
                mintEndAt,
                oneMintPerAddress,
                poapPrice,
                tokenIdPoap,
                isOpenPrice,
                tokenIdAirdrop,
                amountAirdropPerUser,
                airdropWhenHasParticipated,
                hashedPassword,
                lockPresenceUntil,
                eventImage,
                eventName,
                description,
                caller,
                location,
                eventStartAt,
                eventEndAt,
                isPublic,
                isBurnable,
                amountForStorageFees,
                amountForChainFees,
                amountPoapFees,
                totalSupply,
                amountAirdrop    
            )
            
            let mut amountForStorageFeesInContract = minimalContractDeposit!()
            if(amountForStorageFees > 0){
                assert!(amountForStorageFees >= minimalContractDeposit!(), ErrorCodes.NotEnoughAlph)
                amountForStorageFeesInContract = amountForStorageFeesInContract + amountForStorageFees
            }
            
            if(amountForChainFees > 0){
                amountForStorageFeesInContract = amountForStorageFeesInContract + amountForChainFees
            }

            let contractId = copyCreateContract!{caller -> ALPH: amountForStorageFeesInContract, tokenIdAirdrop: amountAirdrop}(    
                collectionTemplateId,
                initialImmState,
                initialMutState
            )

            numMintedCollection = numMintedCollection + 1
            emit EventCreated(contractId, eventName, caller, isPublic, blockTimeStamp!(), false)

            return contractId
        
        }
    
        @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true)
        pub fn mintNewCollectionWithSerie(
            eventImage: ByteVec,
            eventName: ByteVec,
            description: ByteVec,
            isPublic: Bool
        ) -> (ByteVec){
             let caller = callerAddress!()

             let (initialImmState, initialMutState) = PoapSerieCollectionV2.encodeFields!(
                poapTemplateSeriesId,
                poapTemplateDataId,
                caller,

                //event properties
                isPublic,
                eventImage,
                eventName,
                description,
                0,
                0
             )


             let contractId = copyCreateContract!{caller -> ALPH: minimalContractDeposit!()}(    
                collectionTemplateSeriesId,
                initialImmState,
                initialMutState
            )

            numMintedCollection = numMintedCollection + 1
            emit EventCreated(contractId, eventName, caller, isPublic, blockTimeStamp!(), true)

            return contractId

        }

    @using(preapprovedAssets = true, preserveCaller = true)
    pub fn createNewEvent(
        collection: PoapSerieCollectionV2,
        maxSupply: U256,
        mintStartAt: U256,
        mintEndAt: U256,
        poapPrice: U256,
        tokenIdPoap: ByteVec,
        isOpenPrice: Bool,
        tokenIdAirdrop: ByteVec,
        amountAirdropPerUser: U256,
        airdropWhenHasParticipated: Bool,
        eventImage: ByteVec,
        eventName: ByteVec,
        description: ByteVec,
        location: ByteVec,
        eventStartAt: U256,
        eventEndAt: U256,
        isPublic: Bool,
        isBurnable: Bool,
        lockedUntil: U256,
        hashedPassword: ByteVec,
        amountAirdrop: U256
    ) -> (){
        let caller = callerAddress!()
        checkCaller!(caller == collection.getOrganizer(), ErrorCodes.InvalidCaller)
        


       let contractId = collection.addNewEvent{caller -> tokenIdAirdrop: amountAirdrop}(
            maxSupply,
            mintStartAt,
            mintEndAt,
            poapPrice,
            tokenIdPoap,
            isOpenPrice,
            tokenIdAirdrop,
            amountAirdropPerUser,
            airdropWhenHasParticipated,
            eventImage,
            eventName,
            description,
            location,
            eventStartAt,
            eventEndAt,
            isPublic,
            isBurnable,
            lockedUntil,
            hashedPassword,
            amountAirdrop
        )

        emit SerieAdded(collection, contractId, eventName, caller, isPublic, blockTimeStamp!())


    }

    @using(preapprovedAssets = true, checkExternalCaller = false, preserveCaller = true)
    pub fn mintPoapSerie(collection: PoapSerieCollectionV2, eventId: U256, amount: U256, password: ByteVec) -> (){
        let caller = callerAddress!()

        
        let (poapPrice, poapTokenId, isOpenPrice) = collection.getPoapPrice(eventId)
        let mut poapPriceAmount = poapPrice // when isOpenPrice true just set the amount the user wants to pay
        if(isOpenPrice){
            poapPriceAmount = amount
        }

        let poapContractId = collection.mint{caller -> ALPH: dustAmount!(), poapTokenId: poapPriceAmount}(eventId, poapPriceAmount, password)
        let collectionTotalSupply = collection.totalSupply()

        emit PoapSerieMinted(poapContractId, collection, eventId, collectionTotalSupply ,caller, collection.getEventPublic(eventId), blockTimeStamp!())

    }


    @using(preapprovedAssets = true, checkExternalCaller = false, preserveCaller = true)
    pub fn mintPoap(collection: PoapCollectionV2, amount: U256, password: ByteVec) -> (){
        let caller = callerAddress!()

        let collectionAmountAlphInContract = collection.getAmountForStorageFees()

        let mut feesStorageAmount = minimalContractDeposit!()
        if(collectionAmountAlphInContract > 0){
            feesStorageAmount = 0
        }

        
        let (poapPrice, poapTokenId, isOpenPrice) = collection.getPoapPrice()
        let mut poapPriceAmount = poapPrice // when isOpenPrice true just set the amount the user wants to pay
        if(isOpenPrice){
            poapPriceAmount = amount
        }

        let poapContractId = collection.mint{caller -> ALPH: feesStorageAmount, poapTokenId: poapPriceAmount}(poapPriceAmount, password)
        let collectionTotalSupply = collection.totalSupply()

        emit PoapMinted(poapContractId, collection, collectionTotalSupply, caller, collection.getIsPublic(), blockTimeStamp!())

    }

    @using(preapprovedAssets = true, preserveCaller = true)
    pub fn setParticipatedPresence(collection: PoapCollectionV2, nftIndex: U256, presenceAddressValidate: Address) -> (){
        let caller = callerAddress!()

        let organizer = collection.getOrganizer()
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)

        let mut amountDust = 0
        if(collection.getAirdropWhenHasParticipated()){
            amountDust = dustAmount!()
        }
        
        collection.setParticipatedPresence{organizer -> ALPH: amountDust}(nftIndex, presenceAddressValidate)

        emit PoapParticipatedIn(caller, collection, nftIndex, presenceAddressValidate)
    }

    pub fn getNumEventsCreated() -> U256{
        return numMintedCollection
    }

}