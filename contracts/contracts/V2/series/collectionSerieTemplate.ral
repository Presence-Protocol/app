import "std/nft_collection_interface"
Contract PoapSerieCollectionV2(
    nftTemplateId: ByteVec,
    poapDataTemplateId: ByteVec,
    organizer: Address,

    //event properties
    isPublicCollection: Bool,
    collectionImage: ByteVec,
    collectionName: ByteVec,
    collectionDescription: ByteVec,

    mut totalSupply: U256,
    mut totalSupplySeries: U256
  )  extends Utils() implements INFTCollection {

   mapping[U256, PoapData] nftMetadata

   event SerieAdded(collectionId: ByteVec, eventId: U256)
   event PoapMinted(contractId: ByteVec, nftIndex: U256, caller: Address, timestamp: U256)
   event PoapParticipated(organizerAddress: Address, nftIndex: U256)

   @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false, preserveCaller = true)
   pub fn mint(eventId: U256, amount: U256, password: ByteVec) -> (ByteVec) {
     assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
     let eventData = nftMetadata[eventId]


     assert!(eventData.getCurrentSupply() < eventData.getMaxSupply(), ErrorCodes.MaxSupplyReached)
     assert!(blockTimeStamp!() >= eventData.getMintStartAt(), ErrorCodes.MintNotStarted)
     assert!(blockTimeStamp!() <= eventData.getMintEndAt(), ErrorCodes.MintEnded)

     let caller = callerAddress!()
     
     let organizerAddressHex = convert(toByteVec!(eventData.getOrganizer()))
     let (poapPrice, tokenIdPoap, isOpenPrice)  = eventData.getPoapPrice()
 
     let airdropWhenHasParticipated = eventData.getAirdropWhenHasParticipated()
     let hashedPassword = eventData.getHashedPassword()
     let lockPresenceUntil = eventData.getLockedUntil()

     // todo change nftindex to include eventId
     let (initialImmState, initialMutState) = PoapNFTSerieV2.encodeFields!(selfContractId!(), totalSupply, eventData.getImage(), eventData.getName(), eventData.getDescription(), organizerAddressHex, eventData.getLocation(), eventData.getEventStartAt(), eventData.getEventEndAt(), eventData.getIsPublic(), caller, eventData.getIsBurnable(), eventData.getLockedUntil(), false)
     
     let contractPath = toByteVec!(totalSupply)
  

     let mut payer = caller
     let amountForStorageFees = eventData.getAmountForChainFees()
     // pay storage fees if there's alph in contract
     if(amountForStorageFees > 0){
        //eventData.paidStorageFees(selfAddress!())
        payer = contractAddress!(eventData)
     }

     
     if(poapPrice > 0 || isOpenPrice){
        let mut priceToPay = poapPrice
        if(isOpenPrice){
          assert!(amount >= 1, ErrorCodes.NotEnoughAlph)
          priceToPay = amount
        }
        eventData.depositPaidPoap{caller -> tokenIdPoap: priceToPay}(priceToPay)
        
     }

     if(!airdropWhenHasParticipated){
        eventData.sendAirdrop{caller -> ALPH: 0}(caller)
     }

     if(hashedPassword != #00){
      assert!(hashedPassword == keccak256!(password), ErrorCodes.InvalidPassword)
     }


     //let gasFees = txGasFee!()
     //if(amountForChainFees >= gasFees){
     // payGasFee!(selfAddress!(), gasFees)
     // amountForChainFees = amountForChainFees - gasFees
    //}

    let mut contractId = #00
    if(lockPresenceUntil > 0){

    contractId = copyCreateSubContractWithToken!{payer -> ALPH: minimalContractDeposit!()}(
      contractPath,
      nftTemplateId,
      initialImmState,
      initialMutState,
      1)

      PoapNFTV2(contractId).lock(caller, lockPresenceUntil)

    } else {
    emit Debug(`collection payer ${payer}, caller ${callerAddress!()}, self ${selfAddress!()} nftdata ${contractAddress!(eventData)}`)
    //  contractId = copyCreateSubContractWithToken!{payer -> ALPH: minimalContractDeposit!()}(
    //   contractPath,
    //   nftTemplateId,
    //   initialImmState,
    //   initialMutState,
    //   1,
    //   caller)


      contractId = eventData.mint{payer -> ALPH: minimalContractDeposit!()}(payer, contractPath, nftTemplateId, initialImmState, initialMutState)

      emit Debug(`minting`)
    }
      

      emit PoapMinted(contractId, totalSupply, caller, blockTimeStamp!())

      eventData.incrementTotalSupply()
      totalSupply = totalSupply + 1
      
      return contractId
   }

   @using(preapprovedAssets = true, updateFields = true, preserveCaller = true)
   pub fn addNewEvent(
    maxSupply: U256,
    mintStartAt: U256,
    mintEndAt: U256,
    poapPrice: U256,
    tokenIdPoap: ByteVec,
    isOpenPrice: Bool,
    tokenIdAirdrop: ByteVec,
    amountAirdropPerUser: U256,
    airdropWhenHasParticipated: Bool,
    eventImage: ByteVec,
    eventName: ByteVec,
    description: ByteVec,
    location: ByteVec,
    eventStartAt: U256,
    eventEndAt: U256,
    isPublic: Bool,
    isBurnable: Bool,
    lockedUntil: U256,
    hashedPassword: ByteVec,
    amountAirdrop: U256,
    amountForStorageFees: U256,
    amountForChainFees: U256
    ) -> (ByteVec){
      let caller = callerAddress!()
      checkCaller!(caller == organizer, ErrorCodes.InvalidCaller)

      let (initialImmState, initialMutState) = PoapData.encodeFields!(
        selfContractId!(),
        maxSupply,
        mintStartAt,
        mintEndAt,
        poapPrice,
        tokenIdPoap,
        isOpenPrice,
        tokenIdAirdrop,
        amountAirdropPerUser,
        airdropWhenHasParticipated,
        eventImage,
        eventName,
        description,
        organizer,
        location,
        eventStartAt,
        eventEndAt,
        isPublic,
        isBurnable,
        lockedUntil,
        hashedPassword,
        0,
        0,
        0,
        0,
        amountAirdrop
      )
     
      let contract = copyCreateContract!{caller -> ALPH: minimalContractDeposit!(), tokenIdAirdrop: amountAirdrop}(poapDataTemplateId, initialImmState, initialMutState)
      nftMetadata.insert!(caller, totalSupplySeries, PoapData(contract))                  

      let poapData = PoapData(contract)
      emit Debug(`collection ${amountForStorageFees} ${amountForChainFees}`)
      if(amountForStorageFees > 0){
        poapData.depositStorageFees{caller -> ALPH: amountForStorageFees}(amountForStorageFees)
        //transferToken!{caller -> ALPH: amountForStorageFees}(caller, contractIdToAddress!(contract), ALPH, amountForStorageFees)
      }

      if(amountForChainFees > 0){
        poapData.depositChainFees{caller -> ALPH: amountForChainFees}(amountForChainFees)
      }

      emit SerieAdded(selfContractId!(), totalSupplySeries)

      totalSupplySeries = totalSupplySeries + 1

      return contract

   }

   @using(checkExternalCaller = true, preapprovedAssets = true)
   pub fn setParticipatedPresence(eventId: U256, nftIndex: U256) -> (){
      assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
      let eventData = nftMetadata[eventId]

      let caller = callerAddress!()
     
      checkCaller!(caller == organizer, ErrorCodes.InvalidCaller)
      let poapContractId = subContractId!(toByteVec!(nftIndex))
  

      assert!(contractExists!(poapContractId), ErrorCodes.IncorrectTokenIndex)
      PoapNFTSerieV2(poapContractId).setParticipated()

      let airdropWhenHasParticipated = eventData.getAirdropWhenHasParticipated()

      if(airdropWhenHasParticipated){
        let minter = PoapNFTSerieV2(poapContractId).getMinter()
        eventData.sendAirdrop{organizer -> ALPH: dustAmount!()}(minter)
      }

      emit PoapParticipated(caller, nftIndex)

   }

    pub fn getCollectionUri() -> ByteVec {
      return b`data:application/json,{"name": "` ++ collectionName ++ b`", "description": "`++ collectionDescription ++ b`", "image": "` ++     collectionImage ++ b`"}`
    }
    
    pub fn totalSupply() -> U256 {
        return totalSupply
    }

    pub fn totalSupplySeries() -> U256 {
        return totalSupplySeries
    }


    pub fn nftByIndex(index: U256) -> INFT {
        assert!(index < totalSupply, ErrorCodes.IncorrectTokenIndex)
    
        let nftTokenId = subContractId!(toByteVec!(index))
        assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)
    
        return INFT(nftTokenId)
    }

   // pub fn nftByAddress(caller: Address) -> INFT {
   //   let nftToken = INFT(subContractId!(toByteVec!(caller)))
   //   assert!(nftTokenId.isOneMintPerAddress(), ErrorCodes.LimitedMintPerAddress) 
   // assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)
  
   //   return nftTokenId
   //}

    pub fn validateNFT(nftId: ByteVec, nftIndex: U256) -> () {

      let expectedTokenContract =  nftByIndex(nftIndex)
      
      //todo: find a way to validate if limited to one mint per address
      //if (PoapNFTSerieV2(subContractId!(toByteVec!(index))).isOneMintPerAddress()){
      //    expectedTokenContract =  nftByAddress(callerAddress!())
      //

        assert!(nftId == contractId!(expectedTokenContract), ErrorCodes.NFTNotPartOfCollection)
    }

    //pub fn validateNFTAddress(nftId: ByteVec, address: Address) -> () {
      //assert!(oneMintPerAddress, ErrorCodes.LimitedMintPerAddress)
      //let expectedTokenContract =  nftByAddress(address)

      //assert!(nftId == contractId!(expectedTokenContract), ErrorCodes.NFTNotPartOfCollection)
    //}



    @using(preserveCaller = true)
    pub fn claimFunds(eventId: U256, amountToClaim: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)

        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].claimFunds(amountToClaim)

    }

    @using(preserveCaller = true)
    pub fn withdrawStorageFees(eventId: U256, amount: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)
        
        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].withdrawStorageFees(amount)
    }

    @using(preserveCaller = true)
    pub fn withdrawChainFees(eventId: U256, amount: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)
        
        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].withdrawChainFees(amount)

    }

    @using(preserveCaller = true, preapprovedAssets = true)
    pub fn depositStorageFees(eventId: U256, amount: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)
        
        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].depositStorageFees{callerAddress!() -> ALPH: amount}(amount)
    }

    @using(preserveCaller = true, preapprovedAssets = true)
    pub fn depositChainFees(eventId: U256, amount: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)
        
        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].depositChainFees{callerAddress!() -> ALPH: amount}(amount)
    }

    @using(preserveCaller = true)
    pub fn withdrawAirdrop(eventId: U256, amount: U256) -> () {
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)

        assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
        nftMetadata[eventId].withdrawAirdrop(amount)
    }


    pub fn getOrganizer() -> (Address){
      return organizer
    }

    pub fn isCollectionPublic() -> (Bool){
      return isPublicCollection
    }

    pub fn getEventPublic(eventId: U256) -> (Bool){
      assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
      return nftMetadata[eventId].getIsPublic()
    }

    pub fn getPoapPrice(eventId: U256) -> (U256, ByteVec, Bool){
      assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
      return nftMetadata[eventId].getPoapPrice()

    }

    pub fn getPoapDataByEvent(eventId: U256) -> (ByteVec) {
      assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
      return contractId!(nftMetadata[eventId])
    }

   
    pub fn getAmountForStorageFees(eventId: U256) -> U256 {
      assert!(nftMetadata.contains!(eventId), ErrorCodes.IncorrectEventIndex)
      return nftMetadata[eventId].getAmountForStorageFees()
    }



}
