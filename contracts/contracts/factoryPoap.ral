Contract PoapFactory(
    collectionTemplateId: ByteVec,
    poapTemplateId: ByteVec,
    mut numMintedCollection: U256
){

    event EventCreated(contractId: ByteVec, eventName: ByteVec, organizer: Address, isPublic: Bool)
    event PoapMinted(contractId: ByteVec, collectionId: PoapCollection, nftIndex: U256 ,caller: Address, isPublic: Bool)
    event PoapParticipatedIn(organizerAddress: Address, collectionId: PoapCollection, nftIndex: U256, presenceAddressValidate: Address)


    @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true)
    pub fn mintNewCollection(
        maxSupply: U256,
        mintStartAt: U256,
        mintEndAt: U256,
        oneMintPerAddress: Bool,
        poapPrice: U256,
        tokenIdPoap: ByteVec,
        tokenIdAirdrop: ByteVec,
        amountAirdropPerUser: U256,

        //event properties
        eventImage: ByteVec,
        eventName: ByteVec,
        description: ByteVec,
        location: ByteVec,
        eventStartAt: U256,
        eventEndAt: U256,
        isPublic: Bool,
        isBurnable: Bool,

        amountForStorageFees: U256,
        amountPoapFees: U256,
        totalSupply: U256,
        amountAirdrop: U256) -> (ByteVec){
            let caller = callerAddress!()

            let (initialImmState, initialMutState) = PoapCollection.encodeFields!(selfContractId!(),
                poapTemplateId,
                maxSupply,
                mintStartAt,
                mintEndAt,
                oneMintPerAddress,
                poapPrice,
                tokenIdPoap,
                tokenIdAirdrop,
                amountAirdropPerUser,
                eventImage,
                eventName,
                description,
                caller,
                location,
                eventStartAt,
                eventEndAt,
                isPublic,
                isBurnable,
                amountForStorageFees,
                amountPoapFees,
                totalSupply,
                amountAirdrop    
            )
            
            let mut amountForStorageFeesInContract = minimalContractDeposit!()
            if(amountForStorageFees > 0){
                assert!(amountForStorageFees >= minimalContractDeposit!(), ErrorCodes.NotEnoughAlph)
                amountForStorageFeesInContract = amountForStorageFeesInContract + amountForStorageFees
            }

            let contractId = copyCreateContract!{caller -> ALPH: amountForStorageFeesInContract, tokenIdAirdrop: amountAirdrop}(    
                collectionTemplateId,
                initialImmState,
                initialMutState
            )

            numMintedCollection = numMintedCollection + 1
            emit EventCreated(contractId, eventName, caller, isPublic)

            return contractId
        
        }
    
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn mintPoap(collection: PoapCollection) -> (){
        let caller = callerAddress!()

        let collectionAmountAlphInContract = collection.getAmountForStorageFees()

        let mut feesStorageAmount = minimalContractDeposit!()
        if(collectionAmountAlphInContract > 0){
            feesStorageAmount = 0
        }

        let (poapPrice, poapTokenId) = collection.getPoapPrice()

        let poapContractId = collection.mint{caller -> ALPH: feesStorageAmount, poapTokenId: poapPrice}(caller)
        let collectionTotalSupply = collection.totalSupply()

        emit PoapMinted(poapContractId, collection, collectionTotalSupply, caller, collection.getIsPublic())

    }

    pub fn setParticipatedPresence(collection: PoapCollection, nftIndex: U256, presenceAddressValidate: Address) -> (){
        let caller = callerAddress!()

        let organizer = collection.getOrganizer()
        checkCaller!(callerAddress!() == organizer, ErrorCodes.InvalidCaller)
        collection.setParticipatedPresence(caller, nftIndex, presenceAddressValidate)

        emit PoapParticipatedIn(caller, collection, nftIndex, presenceAddressValidate)
    }

    pub fn getNumEventsCreated() -> U256{
        return numMintedCollection
    }

    // Converts a byte array to a hexadecimal string. Used to change the token ID to a readable format.
   pub fn convert(array: ByteVec) -> ByteVec {
        let hexBytes = [b`0`, b`1`, b`2`, b`3`, b`4`, b`5`, b`6`, b`7`, b`8`, b`9`, b`a`, b`b`, b`c`, b`d`, b`e`, b`f`]
        let mut result = #
        for(let mut offset = 0; offset < size!(array); offset = offset + 1) {
            let byte = u256From1Byte!(byteVecSlice!(array, offset, offset + 1)) & 0xFF
            let high = (byte >> 4) & 0x0F
            let low = byte & 0x0F
            result = result ++ hexBytes[high] ++ hexBytes[low]
          }
      
        return result
      }

}