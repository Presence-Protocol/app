import "std/nft_collection_interface"
Contract PoapCollection(
    nftTemplateId: ByteVec,
    maxSupply: U256,
    mintStartAt: U256,
    mintEndAt: U256,
    oneMintPerAddress: Bool,

    //event properties
    eventImage: ByteVec,
    eventName: ByteVec,
    description: ByteVec,
    organizer: ByteVec,
    location: ByteVec,
    eventStartAt: U256,
    eventEndAt: U256,
    isPublic: Bool,
    isBurnable: Bool,

    mut amountForStorageFees: U256,
    mut totalSupply: U256
  ) implements INFTCollection {

   event PoapMinted(contractId: ByteVec, nftIndex: U256, caller: Address)

   @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false, assetsInContract = true)
   pub fn mint(callerAddr: Address) -> (ByteVec) {
     assert!(totalSupply < maxSupply, ErrorCodes.MaxSupplyReached)
     assert!(blockTimeStamp!() >= mintStartAt, ErrorCodes.MintNotStarted)
     assert!(blockTimeStamp!() <= mintEndAt, ErrorCodes.MintEnded)

     let mut caller = callerAddress!()     
     if(isContractAddress!(caller)){ // if called from a contract, need to get the reall caller
        caller = callerAddr
     }

     let (initialImmState, initialMutState) = PoapNFT.encodeFields!(selfContractId!(), totalSupply, eventImage, eventName, description, organizer, location, eventStartAt, eventEndAt, isPublic, caller, isBurnable)
     
     let mut contractPath = toByteVec!(totalSupply)
     if(oneMintPerAddress){
        assert!(!contractExists!(subContractId!(toByteVec!(caller))), ErrorCodes.LimitedMintPerAddress)
        contractPath = toByteVec!(caller)
     }

     let mut payer = caller
     // pay storage fees if there's alph in contract
     if(amountForStorageFees > minimalContractDeposit!()){
        payer = selfAddress!()
        amountForStorageFees = amountForStorageFees - minimalContractDeposit!()
     }

     let contractId = copyCreateSubContractWithToken!{payer -> ALPH: minimalContractDeposit!()}(
         contractPath,
         nftTemplateId,
         initialImmState,
         initialMutState,
         1,
         caller
     )

     emit PoapMinted(contractId, totalSupply, caller)

     totalSupply = totalSupply + 1

     return contractId
   }

    pub fn getCollectionUri() -> ByteVec {

     //if(imageSvg != #00){
     //   return b`data:application/json,{"name": "` ++ eventName ++ b`", "description": "`++ description ++ b`", "image": "` ++ imageSvg ++ b`"}`
     // }

      return b`data:application/json,{"name": "` ++ eventName ++ b`", "description": "`++ description ++ b`", "image": "` ++     eventImage ++ b`"}`
    }
    
    pub fn totalSupply() -> U256 {
        return totalSupply
    }


    pub fn nftByIndex(index: U256) -> INFT {
        checkCaller!(index < totalSupply(), ErrorCodes.IncorrectTokenIndex)
    
        let nftTokenId = subContractId!(toByteVec!(index))
        assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)
    
        return INFT(nftTokenId)
    }

    pub fn nftByAddress(caller: Address) -> INFT {
      assert!(oneMintPerAddress, ErrorCodes.LimitedMintPerAddress)
  
      let nftTokenId = subContractId!(toByteVec!(caller))
      assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)
  
      return INFT(nftTokenId)
  }

    pub fn validateNFT(nftId: ByteVec, nftIndex: U256) -> () {

        if (oneMintPerAddress){
          let expectedTokenContract =  nftByAddress(callerAddress!())

          assert!(nftId == contractId!(expectedTokenContract), ErrorCodes.NFTNotPartOfCollection)
        }else {
          let expectedTokenContract =  nftByIndex(nftIndex)
          assert!(nftId == contractId!(expectedTokenContract), ErrorCodes.NFTNotPartOfCollection)
        }

    }

    pub fn getIsPublic() -> (Bool) {
        return isPublic
    }

    pub fn getAmountForStorageFees() -> U256 {
        return amountForStorageFees
    }

}
